<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="《计算机网络 自顶向下方法》读书笔记——应用层"><meta name="keywords" content="计算机网络"><meta name="author" content="Hans941,undefined"><meta name="copyright" content="Hans941"><title>《计算机网络 自顶向下方法》读书笔记——应用层 | Hans941</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1da26cc1cba04c9315fd8280b3c294d4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-概述"><span class="toc-number">1.</span> <span class="toc-text">1 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-可供程序使用的应用层服务"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 可供程序使用的应用层服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-运输层协议-TCP-和-UDP"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 运输层协议 TCP 和 UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-互联网运输协议所不提供的服务"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 互联网运输协议所不提供的服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-应用层协议"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 应用层协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Web和http"><span class="toc-number">2.</span> <span class="toc-text">2 Web和http</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-HTTP概况"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 HTTP概况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-非持续连接额持续连接"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 非持续连接额持续连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-http报文格式"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 http报文格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-cookie"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-web缓存-代理服务器"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 web缓存/代理服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-条件GET方法"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 条件GET方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-文件传输协议：FTP"><span class="toc-number">3.</span> <span class="toc-text">3 文件传输协议：FTP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-电子邮件"><span class="toc-number">4.</span> <span class="toc-text">4 电子邮件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-SMTP"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 SMTP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-SMTP和HTTP的对比"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 SMTP和HTTP的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-邮件访问协议"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 邮件访问协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-DNS：因特网的目录服务"><span class="toc-number">5.</span> <span class="toc-text">5 DNS：因特网的目录服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS提供的服务"><span class="toc-number">5.1.</span> <span class="toc-text">DNS提供的服务</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://qiniu.hans941.top/avatat.png"></div><div class="author-info__name text-center">Hans941</div><div class="author-info__description text-center">认真的去分享才是美德。</div><div class="follow-button"><a href="https://github.com/hans941" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">2</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">2</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://wx2.sinaimg.cn/large/e264e10ely1fyyds76eypj21hc0u0u0y.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Hans941</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章全览</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/tags">标签</a></span></div><div id="post-info"><div id="post-title">《计算机网络 自顶向下方法》读书笔记——应用层</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-01-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/基础/">基础</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/基础/计算机网络/">计算机网络</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 11 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><h3 id="1-1-可供程序使用的应用层服务"><a href="#1-1-可供程序使用的应用层服务" class="headerlink" title="1.1 可供程序使用的应用层服务"></a>1.1 可供程序使用的应用层服务</h3><blockquote>
<p>研发应用程序的核心是写出能在不同端系统和通过网络彼此通信的程序。  </p>
</blockquote>
<p>由于计算机网络的分层结构，应用层协议只能运行在端系统，这种限制促进了应用程序的开发，即不用考虑底层网络核心的实现。开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有控制权，除了：</p>
<pre><code>1. 选择运输层协议（如果可供选择的话）  
2. 也许能设定几个运输层参数，如最大缓存和最大报文段长度。
</code></pre><p><img src="http://ovr5nczih.bkt.clouddn.com/%E9%80%89%E6%8B%A9%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%9A%84%E8%A6%81%E6%B1%82.JPG" alt=""></p>
<h3 id="1-2-运输层协议-TCP-和-UDP"><a href="#1-2-运输层协议-TCP-和-UDP" class="headerlink" title="1.2 运输层协议 TCP 和 UDP"></a>1.2 运输层协议 TCP 和 UDP</h3><p><strong>TCP服务</strong><br>TCP服务模型包括面向连接服务和可靠数据传输服务。</p>
<ul>
<li>面向连接的服务：在应用层数据报文开始流动之前，TCP 让客户和服务器互相交换运输层控制信息，即握手阶段。之后，一条 全双工 的 TCP 连接 就在两个进程的套接字之间建立了。应用程序结束发送报文时，则拆除该连接。  </li>
<li>可靠的数据传送服务：通信进程能够依靠 TCP，无差错、按适当顺序交付所有发送的数据。</li>
<li>包括拥塞控制机制。</li>
</ul>
<p><strong>拥塞控制机制</strong>，这种服务不一定为通信进程带来直接好处，但是能为因特网带来整体好处： 当发送方和接收方之间的网络出现拥塞时，TCP 的拥塞控制机制会抑制发送进程。TCP 拥塞控制机制也试图限制每个 TCP 连接，使他们达到公平共享网络带宽的目的。  </p>
<p><strong>UDP服务</strong><br>UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。它有如下特点：</p>
<ul>
<li>UDP是无连接的，因此无握手过程。  </li>
<li>不可靠数据传输，即不保证发送报文能完整地、有次序地达到接收进程。  </li>
<li>无拥塞控制机制。</li>
</ul>
<p><img src="http://ovr5nczih.bkt.clouddn.com/%E9%80%89%E7%94%A8tcp%E5%92%8Cudp%E7%9A%84%E7%A8%8B%E5%BA%8F.JPG" alt=""></p>
<h3 id="1-3-互联网运输协议所不提供的服务"><a href="#1-3-互联网运输协议所不提供的服务" class="headerlink" title="1.3 互联网运输协议所不提供的服务"></a>1.3 互联网运输协议所不提供的服务</h3><blockquote>
<p>我们大致可以从四个方面对应用程序服务要求进行分类:可靠数据传输、吞吐量、定时和安全性。</p>
</blockquote>
<p>TCP 能提供可靠的数据传输服务，也能通过 SSL 来加强以提供安全服务。但是对吞吐量、定时这两点网络运输协议并没有提供。<br>这并不意味着如互联网语音通讯这类时间敏感型应用不能运行在今天的互联网上， 想反因特网通常能够为时间敏感应用提供满意的服务，但不能提供任何定时或带宽保证。</p>
<h3 id="1-4-应用层协议"><a href="#1-4-应用层协议" class="headerlink" title="1.4 应用层协议"></a>1.4 应用层协议</h3><blockquote>
<p>应用层协议定义了运行在不同端系统上的应用程式进程如何相互传递报文。</p>
</blockquote>
<p>特别是定义了以下几个方面：</p>
<ul>
<li>交换报文的类型，例如请求报文和响应报文。  </li>
<li>各种报文类型的语法，如报文中各个字段及这些字段是如何描述的。  </li>
<li>字段的语义，即这些字段中包含的信息的含义。</li>
<li>一个进程何时以及如何发送报文，对报文进行响应的规划。</li>
</ul>
<p>应用层协议只是网络应用的一个部分，比如一个Web应用包括文档格式的标准（HTML）、浏览器（firefox、chrome等）、服务器以及一个应用层协议（HTTP）。又比如一个电子邮件应用包括邮件服务器、客户端程序、定义电子邮件报文结构的标准、定义报文传递的应用层协议和定义如何对报文首部进行解释的应用层协议。用于电子邮件的主要应用层协议是SMTP。</p>
<hr>
<h2 id="2-Web和http"><a href="#2-Web和http" class="headerlink" title="2 Web和http"></a>2 Web和http</h2><h3 id="2-1-HTTP概况"><a href="#2-1-HTTP概况" class="headerlink" title="2.1 HTTP概况"></a>2.1 HTTP概况</h3><blockquote>
<p>web的应用层协议是<strong>超文本</strong>传输协议，它是web的核心。<br>http由两个程序实现：一个客户程序和一个服务器程序。他们运行在不同的端系统中，通过http报文进行会话。<br>HTTP使用TCP作为它的支撑运输协议。  </p>
</blockquote>
<p><img src="http://ovr5nczih.bkt.clouddn.com/1.JPG" alt=""></p>
<p>HTTP客户首先发起一个与服务器的TCP连接，一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP。TCP为http提供可靠的数据传输服务，保证每个http请求报文完整地到达服务器，这里体现了分层体系结构的优点。即http不用担心数据丢失，也不关注tcp从网络的数据丢失和乱序故障中恢复的细节，那是TCP以及服务栈较底层的协议的工作。  </p>
<h3 id="2-2-非持续连接额持续连接"><a href="#2-2-非持续连接额持续连接" class="headerlink" title="2.2 非持续连接额持续连接"></a>2.2 非持续连接额持续连接</h3><blockquote>
<p>根据每个请求\响应是由一个个单独的 tcp 进行的，还是所有请求\响应由共同的一个 tcp 连接发送的可分为<strong>持续连接</strong>和<strong>非持连接</strong>（non-persistent connection）。  </p>
</blockquote>
<p><strong><em>1.采用的非持续连接的http</em></strong></p>
<p>比如说我们访问一个包含10个图片的网页，那么该页面包含一个基本的HTML文件和10个图片文件，一共11个对象。<br>我们看看发生了什么情况：  </p>
<ul>
<li>http客户进程在默认端口号80发起一个到服务器的tcp连接，在该服务器和客户分别有一个套接字与该连接相关联。  </li>
<li>http客户经过它的套接字向该服务器发送包含网址的请求报文。  </li>
<li>http服务器经过它的套接字接收请求报文，从存储器中检索出index.html（举例的一个基本的html文件），之后在响应报文中封装该对象，并通过套接字返回响应报文。  </li>
<li>http服务器进程通知tcp断开该tcp连接。  </li>
<li>http客户接收响应报文，tcp连接关闭。检查报文封装HTML对象中包含10个图片引用。  </li>
<li>对每个引用的图片对象重复前4个步骤。  </li>
</ul>
<p>上述例子说明了非持续连接的使用，每个TCP连接只传输一个请求报文和一个响应报文。本例中就产生了11个TCP连接。</p>
<p><strong><em>2.采用持续连接的http</em></strong></p>
<p>非持续连接有一些缺点，会导致每次请求\响应都要建立TCP连接，多花费了很多次“握手”时间，不仅带来了交付时延，还给web服务器到来了负担。HTTP1.1规定了默认保持持续性连接（Connection:keep-alive）。  </p>
<h3 id="2-3-http报文格式"><a href="#2-3-http报文格式" class="headerlink" title="2.3 http报文格式"></a>2.3 http报文格式</h3><ol>
<li><strong>http请求报文</strong></li>
</ol>
<p>下面是一个典型的http请求报文<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /somedir/page.html HTTP/1.1</span><br><span class="line">Host: www.hans941.tk</span><br><span class="line">Connection: close</span><br><span class="line">User-agent: Chrome/57.0</span><br><span class="line">Accept-language: ch</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>http报文用ASCII文本书写，每行由一个回车和换行符结束，最后一行再附加一个回车和换行符。<br>http请求报文的第一行叫<strong>请求行</strong>（request line），其后的行叫<strong>首部行</strong>（header line）。请求行有三个字段：方法字段、URL字段和HTTP版本字段。方法字段包括：GET、POST、HEAD、PUT和DELETE。HEAD方法用于调试跟踪，PUT方法用于向服务器上传文件，DELETE方法用于删除服务器文件。</p>
</blockquote>
<ul>
<li>下图是请求报文的通用格式  </li>
</ul>
<p><img src="http://ovr5nczih.bkt.clouddn.com/%E9%80%9A%E7%94%A8http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.JPG" alt=""></p>
<p>首部行后面的 <code>实体体</code>(Entity body),在使用 <code>POST</code> 方法时存储用户提交的表单。  </p>
<ol start="2">
<li><strong>http响应报文</strong><br><code>`</code><br>HTTP/1.1 200 OK<br>Connection: close<br>Date: Tue, 09 Aug 2011 15:44:04 GMT<br>Server: Apache/2.2.3 (CentOS)<br>Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT<br>Content-Length: 6821<br>Content-Type: text/html</li>
</ol>
<p>(data data data data data ……)<br><code>`</code>  </p>
<blockquote>
<p>上面这个http响应报文由三部分组成：一个初始<code>状态行</code>（status line），之后有6个<code>首部行</code>（header line），然后是<code>实体体</code>（entity body）。</p>
</blockquote>
<p>状态行有三个字段：</p>
<ul>
<li>协议版本字段</li>
<li>状态码</li>
<li>相应状态信息</li>
</ul>
<p>实体体是报文的主要组成部分，它包含了请求的对象本身（即data data…………）。</p>
<p><img src="http://ovr5nczih.bkt.clouddn.com/http%E7%9B%B8%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F.JPG" alt=""></p>
<h3 id="2-4-cookie"><a href="#2-4-cookie" class="headerlink" title="2.4 cookie"></a>2.4 cookie</h3><p>HTTP服务器是无状态化的，这简化了服务器的设计，这让工程师可以去开发能同时处理大量数据的高性能服务器。但是有时Web站点希望能去识别用户，为此HTTP使用了cookie来进行用户跟踪。  </p>
<ul>
<li>cookie 有 4 个技术组件</li>
</ul>
<ol>
<li>在 HTTP 响应报文中的一个 cookie 首部行；</li>
<li>在 HTTP 请求报文中的一个 cookie 首部行；</li>
<li>在用户端系统中保留有一个 cookie 文件，并由用户的浏览器进行管理；</li>
<li>位于 Web 站点的一个后端数据库。</li>
</ol>
<p><img src="http://ovr5nczih.bkt.clouddn.com/cookie%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.JPG" alt=""><br>简单地说，就是用户在首次访问一个网站时，浏览器收到的响应报文里有set-cookie首部，浏览器就会在它管理的特定cookie文件里添加一行，该行包括服务器主机名和set-cookie中的识别码。识别码就标记了用户身份，所以当用户再次访问该网站时，就能继续沿用曾经访问时留下的信息。</p>
<h3 id="2-5-web缓存-代理服务器"><a href="#2-5-web缓存-代理服务器" class="headerlink" title="2.5 web缓存/代理服务器"></a>2.5 web缓存/代理服务器</h3><blockquote>
<p>如果让每个用户都访问服务器来获取信息，这不仅让服务器负载过大，而且面对距离服务器较远的用户会使用户访问速度变慢。为此，有了<code>web缓存</code>(web cache)的出现，web缓存也叫<code>代理服务器</code>（proxy server）。</p>
</blockquote>
<p><img src="http://ovr5nczih.bkt.clouddn.com/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8.JPG" alt=""></p>
<p><code>代理服务器</code>的大概原理可简述如下：  </p>
<ul>
<li>浏览器向代理服务器发送一个请求</li>
<li>代理服务器检查本地是否存储了该请求对象副本。</li>
<li>如果包含则返回该对象，如果没有则代理服务器再向原始服务器发送请求，在成功响应后在本地保存该副本并向客户的浏览器返回响应。</li>
</ul>
<p>使用代理服务器时是如何保证存储的对象是最新的版本呢？这就2.6的内容。</p>
<h3 id="2-6-条件GET方法"><a href="#2-6-条件GET方法" class="headerlink" title="2.6 条件GET方法"></a>2.6 条件GET方法</h3><p>为了保证存放在缓存器中的对象副本是最新的，在GET方法中包含<code>If-Modified-Since:</code>首部行用于存储该对象最后修改的日期。在一段时间后，缓存服务器再次受到用户浏览器的请求时，缓存服务器会向原始服务器发送一个GET请求检查在<code>If-Modified-Since:</code>后该对象是否被修改过，如果被修改过则返回修改过的对象，如果没有则返回一个空的实体体响应报文。</p>
<h2 id="3-文件传输协议：FTP"><a href="#3-文件传输协议：FTP" class="headerlink" title="3 文件传输协议：FTP"></a>3 文件传输协议：FTP</h2><blockquote>
<p>HTTP和FTP都是文本传输协议，他们有很多共同点，例如都运行在TCP上，但他们最显著的区别是FTP使用了两个并行的TCP连接，一个是控制连接，一个是数据连接。控制连接用于控制传输命令（put，get），数据连接用于传输文件数据。</p>
</blockquote>
<h2 id="4-电子邮件"><a href="#4-电子邮件" class="headerlink" title="4 电子邮件"></a>4 电子邮件</h2><p><img src="http://ovr5nczih.bkt.clouddn.com/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9A%84%E5%8F%91%E9%80%81.JPG" alt=""></p>
<p>电子邮件系统有 3 个主要组成部分： <code>用户代理</code>、<code>邮件服务器</code>、<code>简单邮件传输协议（SMTP）</code>。</p>
<h3 id="4-1-SMTP"><a href="#4-1-SMTP" class="headerlink" title="4.1 SMTP"></a>4.1 SMTP</h3><blockquote>
<p>SMTP是网络电子邮件应用的核心，它使用TCP连接和ASCII编码(只能使用ASCII编码意味着传送二进制的多媒体文件会很麻烦)。</p>
</blockquote>
<p>为了描述SMTP的基本操作，我们假设ALice要给Bob发送一封简单的ASCII报文：  </p>
<ul>
<li>Alice调用他的用户代理程序并提供Bob的邮件地址，撰写报文，然后指示用户代理程序发送报文  </li>
<li>Alice的用户代理程序把报文发送给它的邮件服务器，在那里该报文被放在报文队列中  </li>
<li>运行在Alice邮件服务器上SMTP客户端发现报文队列中的报文，它就创建一个连接到Bob邮件服务器上的SMTP客户端的TCP连接  </li>
<li>在经过初始的SMTP握手后，发送报文</li>
<li>Bob的邮件服务器接收报文后，将报文放在Bob的邮箱中  </li>
<li>在Bob方便时，调用他的用户代理程序阅读报文</li>
</ul>
<h3 id="4-2-SMTP和HTTP的对比"><a href="#4-2-SMTP和HTTP的对比" class="headerlink" title="4.2 SMTP和HTTP的对比"></a>4.2 SMTP和HTTP的对比</h3><p>相同点：</p>
<ul>
<li>都由一台主机向另一台主机传送文件</li>
<li>当进行文件传送时，都使用持续连接</li>
</ul>
<p>不同点：</p>
<ul>
<li>HTTP主要是个拉协议，SMTP是个推协议。</li>
<li>SMTP要求每个报文使用7比特ASCII码格式，HTTP则没有这个限制。  </li>
<li>对于既包含文本又包含多媒体文件的文档，HTTP把每个对象封装到他自己的HTTP响应报文中，而SMTP则把所有对象封装到一个报文中。</li>
</ul>
<h3 id="4-3-邮件访问协议"><a href="#4-3-邮件访问协议" class="headerlink" title="4.3 邮件访问协议"></a>4.3 邮件访问协议</h3><blockquote>
<p>当我的邮件服务器有一封邮件，我如何把它取回到我的用户代理程序呢？<br>由于SMTP是一个推协议，我们只能用过引入其他的邮件访问协议来解决这个问题。<br>目前有一些流行的邮件访问协议<code>第三版的邮局协议（POP3）</code>、<code>因特网邮件访问协议（IMAP）</code>以及<code>HTTP</code>。</p>
</blockquote>
<h2 id="5-DNS：因特网的目录服务"><a href="#5-DNS：因特网的目录服务" class="headerlink" title="5 DNS：因特网的目录服务"></a>5 DNS：因特网的目录服务</h2><blockquote>
<p>我们知道因特网的主机可以用主机名（<a href="http://www.baidu.com）或者IP地址（192.168.1.15）来标识。但相对于IP地址，人类认为主机名更加便于记忆，DNS就提供了从主机名到IP地址的转换。" target="_blank" rel="noopener">www.baidu.com）或者IP地址（192.168.1.15）来标识。但相对于IP地址，人类认为主机名更加便于记忆，DNS就提供了从主机名到IP地址的转换。</a><br><code>DNS</code> (Domain Name System)是：一个<code>由分层的DNS服务器</code>（DNS Server）实现的<code>分布式数据库</code>；一个使主机能够查询<code>分布式数据库</code>的<code>应用层协议</code>。<br>DNS服务器通常是运行BIND软件的UNIX服务器；DNS协议运行在UDP之上，使用53号端口。</p>
</blockquote>
<h3 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h3><ul>
<li>和HTTP、SMTP、FTP协议一样，DNS是应用层协议，但是DNS通常是被其他应用层协议使用的，将用户的主机名解析为IP地址。  </li>
<li>主机别名（host aliasing)。一个主机可以拥有多个别名，DNS存储所有的名字。</li>
<li>邮件服务器别名。同上。</li>
<li>负载分配（load distribution）。一个繁忙的站点会被冗余分布在多个服务器上，每台服务器都有不同的IP地址，而DNS会让你在多个服务器之间循环访问，防止所有的用户都访问同一台服务器。</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Hans941</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hans941.top/1-1.html">https://hans941.top/1-1.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hans941.top" target="_blank">Hans941</a>！</span></div></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5c45777fd1d1acc1" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/1.html"><i class="fa fa-chevron-left">  </i><span>laravel5.4数据库迁移错误SQLSTATE[42000] Syntax error or access violation 1071</span></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC80MjI1Mi8xODc5OQ"><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By Hans941</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">已经到底啦 <br><a href="http://www.miitbeian.gov.cn">豫ICP备18031916号</a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>